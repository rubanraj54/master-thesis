\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage[]{hyperref}
\usepackage[super]{nth}
\usepackage{pdflscape}
\usepackage{rotating}
\usepackage{listings}
\usepackage{enumitem}

%\usepackage{bera}% optional: just to have a nice mono-spaced font
\usepackage{listings}
\usepackage{xcolor}
\usepackage[title]{appendix}


\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
	basicstyle=\normalfont\ttfamily,
	numbers=left,
	numberstyle=\scriptsize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{background},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}

\setlist[1]{itemsep=-5pt}
\usepackage[square,numbers]{natbib}

\hypersetup{backref,
			pdfpagemode=FullScreen,
			colorlinks=true,
			urlcolor=blue,
			citecolor=red}
\renewcommand{\baselinestretch}{1.2}

\begin{document}
\title{\Large Comparing centralized and decentralized approaches for software distribution/updates in IoT devices\\
[6mm]
\Large Rubanraj Ravichandran\\
[12mm]
\Large Expos{\'e} - Master Thesis\\
\small Master of Autonomous Systems\\
[12mm]
\Large Department of Computer Science\\
University of Applied Sciences Bonn-Rhein-Sieg\\
[12mm]
\Large Supervisors:\\
Prof. Dr. Karl Jonas\\
\Large Advisors:\\
Farshid Tavakolizadeh
}
\date{\today}
\maketitle
\newpage
\section{Introduction}

In earlier days, updating firmware for a node was a challenging task to perform because the technicians has to visit the site physically to connect with the device and update the firmware/software \cite{ganesan,moorits}. To overcome this issue, an Italian-American automobile manufacturer "Chrysler Automobiles" started sending software updates in USB flash drive via US Postal service to millions of customers\cite{misc01}. 

%Later two hackers demonstrated a zero day exploit on a infotainment system of a Jeep Cherokee and also they stopped the engine and disabled the brakes.

In recent days, as IoT platforms have matured and finds novelty ways to update the device remotely over the air.  Over the air update involves updating the code of a device which is located in remote location. 
Generally in over the air update work flow,  update files will be stored in a centralized server and the device agents will be polling for new updates in regular interval of time or the update will be triggered from central device management system \cite{nilsson}. Once device agents receive the information about new update, all agents will initiate the download process simultaneously which may cause high network traffic load, CPU and memory utilization on centralized server. In a critical scenario where an important security patch need to be deployed in million of devices and the centralized server can handle up to few thousands of concurrent connections, then the remaining requests will be held in queue or requests may be discarded. 

There are solutions to address these problems in server end, for example increasing the hardware resource of centralized server or scaling the number of servers horizontally. But again scaling servers will end up in raising cost and maintenance.

Our idea is to use existing well known decentralized file sharing approaches like BitTorrent P2P protocol and Pragmatic Multicast protocol to deploy software updates in IoT environments rather than optimizing centralized servers to scale for many devices.

%instead of focusing on optimizing centralized servers to scale for many devices, why can't we use existing well known decentralized file sharing approaches like BitTorrent P2P protocol and Pragmatic Multicast protocol to deploy software updates in IoT environments. 

\newpage

This research work focus more on analyzing and evaluating the performance of decentralized ways of deploying updates to remote devices against at least one centralized deployment. Also we implement the best performing decentralized deployment model with our current project  CPSwarm which is funded in the Horizon 2020 program. CPSwarm is a workbench provides tools and methods that helps engineers to build and monitor swarm groups which includes Automotive systems, Robotic vehicles, Swarm logistics \cite{misc11}.

\section{State of the art analysis}

\subsection{Over The Air Updates}

In recent years, IoT devices acquired the capability to communicate wirelessly with other devices/systems which solved many drawbacks in the past such as, Device installation, Debugging, and Firmware updates. Nowadays most of the IoT devices are embedded with at least one form of wireless connectivity which allows people to connect with the device remotely and debug their application or even send updates Over The Air (OTA) \cite{moorits}. In this section, We will discuss about different OTA update models and their communication protocols from literature and IoT service providers.

It is common that functional requirements will change over time and need to be updated several times during already deployed product's usable lifetime \cite{moorits}. To achieve this, it require human help to visit the remote location to update the firmware. But to save time and cost, {\protect\NoHyper\citeauthor{moorits}\protect\endNoHyper} \cite{moorits} proposes a firmware update model for marine Aids to Navigation (AtoN) micro-controller system, which involves sharing the firmware from a \textbf{central server}\cite{moorits} via GSM/GPRS module in the device. Results shows that downloading firmware of different sizes \textbf{71.63 KB, 79.02 KB} over the air consumes \textbf{~56 sec and ~60 sec} respectively. It is not clearly mentioned, whether the experiment results derived from a single device or group of device. Even if the results are concluded from a single device, the time consumption is quite higher for such a small data package.

{\protect\NoHyper\citeauthor{ganesan}\protect\endNoHyper} \cite{ganesan} proposes a solution to update the firmware for vehicles that helps OEMs to reduce cost, reduce recalls, increase quality, and easy vehicle updates \cite{ganesan}. There are few critical problems mentioned in this paper regarding OEM, dealer and consumers:
\begin{itemize}
	\item Complexity in managing multiple software versions
	\item Each ECU update takes about 15-90 minutes \cite{ganesan}
	\item Limitation of time and equipment availability 
	\item Negative impact on reputation
\end{itemize}

FOTOMOTIVE OTA update process eliminate the need of requesting car owners to visit the service centers to update the new firmware and solves the problems which are mentioned above. Every time during vehicle start, IVIS check with the \textbf{central server} for a new update. Again in this approach, centralized software distribution is used similar to \cite{moorits}, but the details of how fast the update file has shared between the vehicles is not discussed.

\subsection{BitTorrent}


{\protect\NoHyper\citeauthor{lee2016blockchain}\protect\endNoHyper} \cite{lee2016blockchain} introduces a secure firmware update model which uses blockchain for firmware check and validation, and \textbf{BitTorrent protocol} for peer-to-peer firmware sharing \cite{lee2016blockchain}. In this model, group of devices connected in a network represents blockchain network and each device is considered as a blockchain node which stores the device identity and firmware version. To maintain the firmware version integrity, a node will send a firmware version check request to other nodes in the blockchain. Node that receives the request, will check whether the version in the request is same or smaller than its current firmware version. If the version is smaller than its current version, then a list of peer information will be provided as a response. Then the \textbf{node tries to download the update file from it peers} using bittorrent client. 

%Firmware version integrity is maintained by devices makes request to blockchain nodes and receives response which explains whether the current firmware version is latest or outdated. If the version is outdated, then a list of peers information will be provided as a respone. Then the \textbf{device tries to download the update file from it peers} using bittorrent client. 

There are three types of nodes in the proposed model \cite{lee2016blockchain}, Verification node, Vendor node and Device node. Device node which acts as a request/response node, Vendor node makes a secure channel with Verification node to provide update files and at last Verification node verifies the firmware packages per device model and also acts as a tracker for bittorrent protocol. The number of tracker nodes $V$ (Verficiation node) are proportional to number of Device nodes $N$ in the network, which in turn leads to \textbf{increase in distribution and management cost} \cite{lee2016blockchain}. 

$$V \propto N$$
To avoid this problem, \textbf{authors suggest} to use \textbf{Distributed Hash Table} (DHT) implementation with BitTorrent protocol to avoid trackers in the model.

{\protect\NoHyper\citeauthor{herry2018peer}\protect\endNoHyper} \cite{herry2018peer} highlights the problem of deploying secure software updates to large number of heterogeneous devices with existing protocols and also propose a decentralized peer to peer software deployment model which enables \textbf{``secure, scalable, and cost-effective system updates''} \cite{herry2018peer}.  This system relies on BitTorrent to achieve peer-to-peer network and also uses STUN-based UDP hole punching to connect with devices which operates behind the Network Address Translators (NAT) or firewalls. This approach make sure the node with partial connectivity or node operates behind the firewall will get the update file.

\subsection{Pragmatic Multicast}

{\protect\NoHyper\citeauthor{marrone}\protect\endNoHyper} \cite{marrone} analyzed the performance of multicast file transfer over traditional client server file transfer model using PGM and File Transfer Protocol (FTP) respectively. Test results shows that, PGM utilizes the network bandwidth more effectively up to 97.1\% \cite{marrone} and keeping the transfer rates constant through out the file transfer.

Unlike TCP (unicast), PGM multicast the packets to all receivers at the same time which eliminates the individual connections between sender and receiver. Also at the initial stage of file transfer TCP send packets slower due to TCP congestion control but PGM does not have a congestion control which makes PGM send packets at the faster rate. Authors states that, \textbf{``PGM, assuring a simultaneous transmission achieves a file transfer service incomparable to TCP''} \cite{marrone}.


\section{Existing IoT services}

\subsection{AWS IoT}

AWS IoT service offers two different services to connect with fleet of devices and analyze data.

\begin{itemize}
	\item Amazon FreeRTOS
	\item Amazon Greengrass	
\end{itemize}


Amazon FreeRTOS which is an operating system which can be installed only in micro controllers. It supports only the following hardwares:

\begin{itemize}
	\item ESP32-DevKitC \& ESP-WROVER-KIT
	\item Curiosity PIC32MZ EF Amazon FreeRTOS Bundle
	\item LPC54018 IoT Module
	\item STM32L4 Discovery Kit IoT Node
	\item SimpleLink Wi-Fi CC3220SF Wireless Microcontroller LaunchPad Development Kit.	
\end{itemize}


Amazon FreeRTOS OTA streaming service stream the \textbf{update files over MQTT message service} as chucks of small files. Each message can carry up to \textbf{2MB of update file chunk} \cite{misc03}.

It offers two interface, HTTP/CLI interface to create and manage streams, and MQTT interface to send the real update files. Using HTTP/CLI interface users can create a stream, list all existing stream, or delete a stream.  In simple words, creating a stream is creating a configuration which contains the stream information, description and version of the update package, location information about where the file is actually stored (for e.g, Amazon s3). MQTT interface then publish the update package chunks \ref{appendix:aws_freeRtosMessage} over the topic \\ \textbf{``\$aws/things/$<$thingName$>$/streams/$<$streamID$>$/get"}. FreeRTOS OTA agent which is running in device, receive the update package chunks via stream and apply the new update to the micro controller. 

As an additional advantage, it offers security and integrity check out of the box. Observed limitations of FreeRTOS are, it supports specific range of micro controllers, p2p update sharing is not supported and each device has to publish a message to download the update package and if the number of device is more it may slow down the update process.

\textbf{Amazon greengrass} is a software that offers IoT device management includes collect data from device, data visualization and analysis, and firmware update over the air \cite{misc04}. We concentrate only on how update process has been carried out over the air since our work is to analyze the performance of centralized and decentralized software deployment.

Greengrass core package consists of many components, among them agent component takes care of over the air updates. If a new update package is made available, then new job description \ref{appendix:aws_greengrassCmd} will be notified to all agents to  trigger the OTA update process. It should be noted from the job description \ref{appendix:aws_greengrassCmd} that, agent is capable of updating the \textbf{Greengrasss core software and the agent itself} \cite{misc04} but not the software packages which are installed by users. Also, this platform deploys update package via centralized repository and \textbf{does not support decentralized update package sharing} which our approach is focusing on. 

Limitations of Amazon greengrass are, each node should always be connected with cloud to get the regular updates and should have local storage three times more than the amount of the core's runtime usage requirement.


\subsection{Azure IoT Hub}

Similar to AWS IoT platform, Microsoft Azure IoT Hub offers services to connect with IoT devices to collect telemetry data and make them available in the cloud for futher processing and analysis. Azure IoT Hub offers a way to update the firmware or software in group of IoT devices, but it is not same as AWS IoT platform. In AWS IoT, AWS update agent will take care of downloading the image and apply the patches, but in Azure platform a update message will be triggered to targeted devices and \textbf{application code have to manage the downloading and patching processes} \cite{misc05}.

The core difference between them is, AWS update agent can only update the AWS software or update agent itself in device and developers does not need to write code for this. But in Azure IoT Hub, there is \textbf{no update agent running in the device}, instead developers have to write code in their application in such a way that the app can reveice update message from Azure IoT Hub and start downloading the update package from the resource location and apply the patches. Update message will hold the information of where the update package location, version, targeted devices, target condition, and priority.

As a conclusion, Azure IoT Hub device client is not responsible for complete over the air update process. The \textbf{sole responsibility of Azure IoT Hub in terms of OTA update} is simply sending an update message to targeted devices to \textbf{trigger the update process} \cite{misc05} (developers have to write code to do the update process). Software distribution is based on centralized approach and it is not open source.

\subsection{Particle}

Particle is a open source hardware/software platform for Internet of Things. It offers different micro controllers with various hardware configurations and also provides powerful device management tool as a cloud service. Using the cloud service, one can manage the device, check their health status, and can update device OS and as well as application firmware via OTA \cite{misc06} which is not provided by Amazon AWS IoT and Microsoft Azure Hub. But OTA update is limited to native particle micro controllers and Raspberry Pi (only if Particle Agent installed). Also it does not support decentralized software deployment.

\subsection{Resin.io}
Resin.io provides extensive service to deploy the firmware updates to fleet of devices which are running in \textbf{Linux platform}. To connect a device with Resin.io cloud platform, device should be installed with Resin OS which is a Yocto Linux based host OS comprise of Balena a lightweight Docker-compatible container engine \cite{misc07}. Resin OS can be downloaded from resin platform for different architectures and once it is installed in an IoT device, a resin.io device supervisor container will be created and it takes care of the communication between device and Resin.io cloud platform. This is \textbf{very simple and easy to scale} deployments to fleet of devices but it should be noted that similar to other IoT services Resin.io \textbf{does not support decentralized deployment}.\\

\noindent The deployment workflow of Resin.io platform is as follows:\cite{misc08}

\begin{itemize}
	\item Add a new device in the platform and download resion OS for the specific device.
	\item Install the OS in any IoT device and in few minutes the device will be connected to Resin platform.
	\item For each device, a new repository will be created. 
	\item Deployment process starts with just a simple "git push resin master" command, and the "resin" remote location directs to the newly created repository.
	\item Whenever there is a new commit in master branch, resin platform automatically build a new docker image and notify the supervisor in the device.
	\item Then the device supervisor will download the new image and update the currently running docker containers with the new image.	
\end{itemize}

In most of the industrial and agricultural scenarios, IoT devices will be installed closer together and connected in the same network. To improve the efficiency of software deployments and overcome network latency issues in a crowded IoT environments, we could employ decentralized software deployments to send deployment once and make it available in all devices. 

\subsection{Mender}
Mender is an open source remote software updater for embedded Linux devices. Using Mender one can manage all the connected devices and deploy software packages remotely over any TCP/IP network.

\noindent The deployment workflow of Mender platform starts from device software build system and it is responsible to build artifacts for specific device target platforms and to inform \textbf{Mender management server which is the central point for deploying updates} \cite{misc09} to group of devices. Management server keeps track of the current software version that is installed on each device and also schedules roll out for new version updates. 

Updater client in each devices polls the management server in specific interval of time for new updates and if there is a new update available, it will download and install the update and report back to management server about the deployment status.

It doesn't support decentralized software update deployment. One can host mender management server in a local user space since it is open source but Resin.io is free only up to first 10 deceives. 

\subsection{Eclipse hawkBit}

Eclipse hawkBit is a new arrival in the market which is completely domain independent back-end framework for deploying software updates to constrained edge devices \cite{misc10}. There are three different interfaces available for devices to communicate with hawkBit server:

\begin{itemize}
	\item Management API
	\item Direct Device Integration API
	\item Device Management Federation API
\end{itemize}

Developers have to write their own device agents which uses any one of the above interfaces to communicate with hawkBit server and this mechanism works similar to Microsoft Azure IoT. During initial device authentication and authorization with server, client and hawkBit server exchanges basic configurations (for e.g. polling interval, device OS version, MAC address, etc.). Agent in the device is responsible to download and update the firmware or software based on the given meta data which is downloaded along with the update package and share the current update status back to server.

hawkBit device management UI offers easy access to fleet of devices, orchestrate and schedule roll-out plans. hawkBit server is completely open source and can be self hosted with provided docker images. Also it is noted that, firmware/software update package will be shared to target devices only with centralized server.

\section{Problem formulation}

The problem discussed in this work is, there is no specific IoT tool available in the market which supports decentralized software/firmware OTA update. There are research works has been done before to deploy firmware update over decentralized model, but there is no comparative analysis has been done to show the performance of decentralized software updates against centralized approach.

Internet of Things plays major role in our everyday life as most of our daily activities involves use of Internet and exchanging data. At the same time it could lead to some major issues like privacy and security. Software vulnerability is a security hole or weakness found in the program which gives a way to hackers to access the user data and potentially outbreak physical devices. Device control management can immediately fix the security hole and roll out updates to patch the vulnerability in all the devices. But, what is the best way to roll out updates quickly in a reasonable amount of time with less usage of resources? Centralized or Decentralized update roll out?  Is there a tool available to achieve decentralized update management in IoT environment? 

In this research work, we will build a test bed to compare the performance of centralized and decentralized software update over the air. Also we review the current tools that offers over the update feature in IoT devices and we compare the performance of decentralized approaches BitTorrent and Pragmatic General Multicast against the tools which offers centralized software update over the air. Result of this work will be a benchmarking guide to the IoT community to decide which approach will be most suitable for over the air updates and also the tool will be published as open source which in turn help people to achieve decentralized software update over the air.
\\

\section{Methodology}
To investigate this research, we begin with SOA analysis to find out approaches that has been followed through before for similar problem. Afterwards, an extensive qualitative comparison will be carried out which includes finding the existing IoT device management tools that are capable of doing OTA updates. The need of qualitative analysis is to understand the features and work flow of OTA updates in IoT environment,  and also to observe advantages and deficits. At the end of quantitative analysis, few suitable candidates will be selected for performance comparison with our implementation. 

As discussed in introduction, in our approach we would like to use decentralized file sharing approaches for OTA software deployment and compare the performance with centralized approach. To do so, we design and implement a testbed which supports two well-known decentralized protocols called Bit Torrent (Peer-Peer) and Pragmatic General Multicast (PGM). 

\subsection{BitTorrent}

BitTorrent is a well-known peer-to-peer file sharing protocol. It allows \textbf{downloading same file by multiple users (peers)} and at the same time peers shares missing file chunks with each other. This method is know as tit-for-tat to achieve \textbf{Pareto efficiency} \footnote{Pareto principle also known as the 80/20 rule, is a theory maintaining that 80 percent of the output from a given situation or system is determined by 20 percent of the input \cite{misc02}.}. In traditional client server paradigm, a file will be stored in a centralized server that need to be shared with multiple users which causes more traffic to the server. But BitTorrent redistributes this traffic with the downloaders which makes unlimited number of downloaders affordable \cite{cohen2003incentives} with single centralized server.

\begin{figure}[h!]
	\includegraphics[width=13cm,height=9cm]{bittorrent.png}
	\caption{ BitTorrent file sharing model\cite{bittorrent_arch}}
	\label{fig:bittorrent}
\end{figure}

%\textbf{How it works?}

A torrent file with an extension of .torrent will be downloaded by the users to initiate the file download. This .torrent file contains details about file length, name, hashing information and the URL of a tracker. Trackers are servers which have the information about the peers in the network. Using trackers, a peer can find other peers who have the complete or partial file. Once a peer receives the location of other peers, it will send request to all peers for missing chunk in the file.  By default BitTorrent allow peers to handle four upload request at a given point of time, which is also known as \textbf{unchocking}. Unchocking help peers to have limited number of upload request, hence it will not affect the download speed of the peer. For example, if hundred peers requesting for a piece of information to peer A and if peer A responds for all hundred peers then it might affect its own download speed. Unchocking peers is completely dependent on current download rate \cite{cohen2003incentives}.   

The peers with incomplete file are called \textbf{leeches}, and peers with complete file and still uploading the file to other peers are called \textbf{seeders}. To make Bittorrent network works efficiently, it is always advisable to seed the files even after the download completes. 

In our decentralized file sharing approach, fleet of IoT devices will act as clients/peers and update package will be served from a web server as shown in \autoref{fig:bittorrent}. 


\subsection{Pragmatic General Multicast}

Pragmatic General Multicast is a reliable multicast protocol to \textbf{transport packets from multiple senders to multiple receivers} in an orderly fashion. PGM uses a hybrid scheme including suppression, NAK elimination, constraint forwarding and Forward Error Correction (FEC) scheme to achieve scalability \cite{Gemmell20021P}. PGM is clever enough to detect packet loss through unicasting Negative Acknowledgment (NAK) which is sent by receiver who lost the packet. NAK message reaches the sender by hopping Network Elements (NE). So whenever a NAK message is received by a Network Element, it will multicast a NCF (Negative Confirmation) to all receivers/NE's in the downstream. 

\begin{figure}[h!]
	\includegraphics[width=12cm]{pgm_arch.png}
	\caption{ NAK/NCF scenario \cite{Gemmell20021P}}
	\label{fig:pgm}
\end{figure}
\newpage

Multicating NCF to all the nodes in the downstream will avoid the duplicate NAK messages from other receivers. For example, same packet might be lost for two receivers. In this case, the receivers will not send NAK message immediately, but they will wait for a random interval of time. During this wait period, there is a chance for receivers to get a NCF message for the packet which they lost. This mechanism improves the NAK elimination which leads to solve a big issue called network congestion. Overall, PGM utilizes full network bandwidth to transfer the packets more reliably from sender to multiple receivers.

In our approach, the device nodes will act as receivers which receives file chunks via multicast from a single sender as shown in \autoref{fig:pgm}.
 
\noindent Followed by testbed implementation, we do experiments with our defined set of IoT OTA update usecases against set of performance metrics(will be defined after SOA analysis) and observe the performance between centralized and decentralized approaches.

\subsection{Use cases}
Need to be defined

\section{Workplan}
This workplan shows the major decomposition of the workpackages, start time and end time. This project starts on August \nth{15}, 2018 for 6 months duration and ends on February \nth{15},2018.
\newpage
\subsection{Work packages}
\begin{figure}[h!]
  \includegraphics[width=\linewidth]{wp_v1_3.png}
  \caption{Work packages}
  \label{fig:work_packages}
\end{figure}
\newpage

\begin{landscape}
	\subsection{Gantt Chart}
	\begin{figure}[h!]
	  \includegraphics[width=20cm,height=11cm]{time_line_v1_3.png}
	  \caption{Gantt Chart}
	  \label{fig:gantt_chart}
	\end{figure}
\end{landscape}

\newpage
\section{Deliverables}
\subsection{Minimum}
\begin{itemize}
\item Report on state of the art analysis.
\item Collection of existing IoT device management tools which are capable to do OTA updates.
\item Qualitative comparison of these tools based on the work flow, advantages and disadvantages.
\end{itemize}
\subsection{Expected}
\begin{itemize}
\item Designing and implementing test bed for peer-peer and multicast protocol.
\item Running experiments and collection of results.
\item Analysis of results.
\end{itemize}
\subsection{Maximum}
\begin{itemize}
\item Incorporate best performed decentralized file sharing protocol with CPSwarm platform to handle OTA update.
\end{itemize}

%\section{References}
\bibliography{bibfile}
\bibliographystyle{agsm}

\newpage
\appendix
\section{Appendix}
\subsection{Command to trigger OTA update via MQTT interface \cite{misc03}}
\label{appendix:aws_freeRtosCmd}
\begin{lstlisting}[language=json,firstnumber=1]
aws iot describe-stream --stream-id 111
{
  "streamInfo": {
  "streamId": "111",
  "streamArn": "arn:aws:iot:us-west-2:xxx:stream/111",
  "streamVersion": 1,
  "description": "an OTA stream",
  "files": [
    {
      "fileId": 123,
      "s3Location": {
        "bucket": "my-ota-bucket",
        "key": "1af68405-b481-4dc5-b2f8-4e12e1515649"
      }
    }
  ],
  "createdAt": 1529535495.523,
  "lastUpdatedAt": 1529535495.523,
  "roleArn": "arn:aws:iam::123456789012:role/OTA\_SERVICE\_ROLE"
  }
} 

\end{lstlisting}


\subsection{Structure of message received in device (AWS FreeRTOS) \cite{misc03}}
\label{appendix:aws_freeRtosMessage}
\begin{lstlisting}[language=json,firstnumber=1]
{
    "v":number, message version
    "t":"string", client token (optional)
    "s":number,  expected stream version (optional)
    "f":number, file ID
    "l":number, the block size
    "o":number, block offset
    "n":number, the no of blocks to send
    "b":binary, the block bitmap
}
\end{lstlisting}

\subsection{Example of Greengrass core software update job description}
\label{appendix:aws_greengrassCmd}
\begin{lstlisting}[language=json,firstnumber=1]
aws greengrass create-software-update-job \
--update-targets-architecture x86\_64 \
--update-targets arn:aws:iot:us-east-1:xxx:thing/myDevice \
--update-targets-operating-system ubuntu \
--software-to-update core \
--s3-url-signer-role arn:aws:iam::xxx:role/IotS3UrlPresigningRole \
--update-agent-log-level WARN \
--amzn-client-token myClientToken1 	
\end{lstlisting}

\end{document}
