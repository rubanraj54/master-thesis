Designing robust and efficient mediator architecture.

Mediator architecture divided in to three sections:

Producer / Consumer:

  - Any robots or tools which consumes
the data from data sources or produces data to the data sources via the mediator.

component

Mediator:

 Consists of two major components:
 Each component is developed as an individual isolated component for modular and portability.
 - Schema registry
	sequential process of registering **entities** with the mediator and creating buckets if necessary.
	Task, Robot, Sensor, TaskRobotSensor, **Observation**
	Observation is a generic entitiy.
  - Schema registration workflow
	Registering schema with the mediator is a necessary process (because intially mediator has no prior assumptions of the task, robot and sensor)
	Schema registry component exposes endpoint (that allows users or robots directly register their schema configuration)
	show sample Schema configuration
	Show the Flowchar diagram.
	
  - Observation bucket creation workflow
	Each successful sensor registration should have one observation bucket.
	Create buckets in all possible databases/datasources specified in the mediator config.
	Update the changes in the GraphQL component.
	show workflow.
		
  - Entity database mapping strategy:
	// Defines which entities needs to be created in which databases.
	Assign each entity to a database except Observation entity.
	Observation entity can be mapped to more than one database.
	show config image. 
	

  - JSON Schema to GraphQL Schema transformation
	Get JSON Schema from the 'valueSchema' attribute in sensor object.
	Generate a model prototype from the JSON schema. (This model prototype resembles precisely
the same as the observation that will be generated by the sensor in the future)
	Schema registry creates an GraphQL schema based on the prototype and updates the current GraphQL schema. 
	
 - GraphQL mediation
	Built on top of express server and Apollo GraphQL wrapper.
	Mediator components consists of four mandatory modules,
	Type definitions - consists of data type defintions of all entities.
	Mutations - Functions that handles the incoming data and write/update in the database
	Queries - Services to fetch data from different databases.
	Model packages - Model definitions of each entity for all supported databases.
	Mediator currently support MongoDB and MySQL, But we could configure any SQL database with the current mediator system.
  - Connection pool management

Data sources:

A datasource can be any databases, microservices or an API endpoint.
GraphQL component serves as a bridge between the robot and data sources.
In the current work we used only MOngoDB and MySQL as datasources.
Mediator can extend to support other databases with little modifications in the GraphQL Queries and Mutaion module.

Summary:
